# shortest-path

Дан граф G(V, E) G(V,E)  с компонентой связности равной 1. Граф задается матрицей расстояний между вершинами distance_matrix, где distance_matrix[i][j] - расстояние между i и j вершинами. Если distance_matrix[i][j] = 0, то не существует пути из i вершины в j. Необходимо пройти по всем вершинам и вернутся в исходную так, чтобы суммарный путь был минимальным. Начало пути следует начинать с первой вершины. Разрешается проходить по одной вершине несколько раз.

На вход программы подается в первой строке количество вершин n, далее следует матрица расстояний. 
Данные записываются в словарь (номер вершины - ключ) и хранятся в виде: 
{'0': {'1': 2, '2': 2}, '1': {'0': 2, '2': 2, '3': 2}, '2': {'0': 2, '1': 2, '4': 2}, '3': {'1': 2}, '4': {'2': 2}}

функция traverse() обходит граф (из стартовой точки '0') и ищет пути, содержащие все вершины.
функция paths() ищет пути из вершины frm до to, из которых в последствии выбирается кратчайший.

После очередного варианта прохода, содержащего все вершины, в minResults записывается длина пути.
Финальный вариант списка minResults может выглядеть следующим образом (всего 24 вариантов обхода, минимальное значение пути - '14'):
[18, 16, 14, 14, 16, 18, 16, 18, 16, 18, 14, 14, 14, 14, 18, 16, 18, 16, 18, 16, 14, 14, 16, 18]
